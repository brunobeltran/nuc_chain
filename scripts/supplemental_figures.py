#plotting parameters
from pathlib import Path

import matplotlib.cm as cm
import numpy as np
import seaborn as sns
import pandas as pd
from matplotlib import pyplot as plt
import scipy
from scipy import stats
from scipy.optimize import curve_fit
from nuc_chain import geometry as ncg
from nuc_chain import linkers as ncl
from MultiPoint import propagator
from nuc_chain import fluctuations as wlc
from nuc_chain.linkers import convert
from mpl_toolkits.axes_grid1 import make_axes_locatable

# Plotting parameters
# PRL Font preference: computer modern roman (cmr), medium weight (m), normal shape
cm_in_inch = 2.54
# column size is 8.6 cm
col_size = 8.6 / cm_in_inch
default_width = 1.0*col_size
aspect_ratio = 5/7
default_height = aspect_ratio*default_width
#These follow Andy's plotting preferences for
medium_params = {
    'axes.edgecolor': 'black',
    'axes.grid': False,
    'axes.titlesize': 8.0,

    'axes.linewidth': 0.75,
    'backend': 'pdf',
    'axes.labelsize': 8.5,
    'legend.fontsize': 8,

    'xtick.labelsize': 7,
    'ytick.labelsize': 7,
    'text.usetex': False,
    'figure.figsize': [col_size, col_size*(5/7)],

    'font.family': 'sans-serif',
    'font.sans-serif': 'Arial',

    'mathtext.fontset': 'stixsans',
    'savefig.format': 'pdf',
    'xtick.bottom':True,
    'xtick.major.pad': 2,
    'xtick.major.size': 4,
    'xtick.major.width': 0.5,

    'ytick.left':True,
    'ytick.right':False,
    'ytick.major.pad': 2,
    'ytick.major.size': 4,
    'ytick.major.width': 0.5,
    'ytick.minor.right':False,
    'lines.linewidth':1
}
plt.rcParams.update(medium_params)
teal_flucts = '#387780'
red_geom = '#E83151'
dull_purple = '#755F80'
Klin = np.linspace(0, 10**5, 20000)
Klog = np.logspace(-3, 5, 10000)
Ks = np.unique(np.concatenate((Klin, Klog)))
#Kprops = wlc.tabulate_bareWLC_propagators(Ks)

#compare linker propagators generated by ODE solver vs. Quinn/Shafiq's partial fractions solution in Laplace space
def calculate_GKN_Quinn_vs_Deepti(l, l0, j, Ks=Ks, Ns=np.array([0.1, 1.0, 10, 100])):
    """Plotting code for G(K;N) vs K for a given l, l0, j. Plots one curve for each N."""

    Gs = np.zeros((Ns.size, Ks.size), 'complex')
    qGs = np.zeros((Ns.size, Ks.size), 'complex')
    for nn in range(Ns.size):
        for kk in range(Ks.size):
            qGs[nn, kk] = Kprops[kk].get_G(Ns[nn], l0, l)
            Gs[nn, kk] = wlc.get_G(Ks[kk], Ns[nn], l, l0, j)
        ax.loglog(Ks, np.abs(Gs[nn, :].real), color = colors[nn], label='ODE solution')
        ax.loglog(Ks, np.abs(qGs[nn, :].real), '--', color = colors[nn], label='Laplace solution')
        ax.loglog(Ks, np.sin(Ks*Ns[nn])/(Ks*Ns[nn]), ':', color = colors[nn], label='sin(KN)/(KN)')

    ax.legend(frameon=True)
    plt.xlabel('K')
    plt.ylabel('G(K;N)')
    plt.title(f'$l={l}, l_0={l0}, j={j}$')
    plt.legend([f'N={N}' for N in Ns])
    plt.ylim([10**-12, 2])
    plt.show()
    return Gs

def plot_GKN_Quinn_vs_Deepti(Ks=Ks, Ns=np.array([0.1, 1.0, 10, 100])):
    fig, ax = plt.subplots(figsize=(7.21, 5.19))
    colors = sns.color_palette()
    for nn in range(Ns.size):
        ax.loglog(Ks, Gs[nn, :].real, color = colors[nn], label=f'N={Ns[nn]}, ODE')
        ax.loglog(Ks, qGs[nn, :].real, '--', color = colors[nn], label=f'N={Ns[nn]}, Laplace')

    plt.legend(fontsize=14)
    plt.xlabel('K')
    plt.ylabel('G(K;N)')
    plt.title(f'$l={l}, l_0={l0}, j={j}$')
    plt.ylim([10**-8, 2])
    plt.xlim([10**-3, 10**4])
    plt.subplots_adjust(left=0.15, bottom=0.16, top=0.91, right=0.95)
    plt.savefig('plots/props/GKN_quinnWLC_vs_deeptiWLC_linker_prop.png')

def plot_GKN_rigid_rod_vs_kinked(Ks=Ks, Ns=np.array([0.1, 1.0, 10])):
    """Plotting code for G(K;N) vs K for a given l, l0, j. Plots one curve for each N."""
    fig, ax = plt.subplots(figsize=(7.21, 5.19))
    colors = sns.color_palette()
    for nn in range(3):
        ax.loglog(Ks, Gs[nn, :].real, color = colors[nn], label=f'N={Ns[nn]}, ODE solution')
        ax.loglog(Ks, np.sin(Ks*Ns[nn])/(Ks*Ns[nn]), ':', color = colors[nn], label=f'N={Ns[nn]}, sin(KN)/(KN)')

    plt.legend(fontsize=14)
    plt.xlabel('K')
    plt.ylabel('G(K;N)')
    plt.title(f'$l={l}, l_0={l0}, j={j}$')
    plt.ylim([10**-8, 2])
    plt.xlim([10**-3, 10**4])
    plt.subplots_adjust(left=0.15, bottom=0.16, top=0.91, right=0.95)
    plt.savefig('plots/props/GKN_rigid_rod_vs_deeptiWLC_linker_prop.png')

def plot_kuhns_long_linkers_figa():
    links = np.load('csvs/linker_lengths_homogenous_so_far.npy')
    kuhns = np.load('csvs/kuhns_homogenous_so_far.npy')
    fig, ax = plt.subplots(figsize=(0.7*col_size, 0.42*col_size))
    ax.plot(links, kuhns, '-o', markersize=1, lw=0.75, color=teal_flucts, label='Chromatin')
    ax.plot(np.linspace(min(links), max(links), 1000), np.tile(100, 1000), '--', lw=0.75, label='Bare DNA', color=dull_purple)
    plt.xlabel('Fixed linker length (bp)')
    plt.ylabel('Kuhn length (nm)')
    plt.xscale('log')
    plt.legend(loc=4) #lower right
    plt.subplots_adjust(left=0.19, bottom=0.28, top=0.98, right=0.99)
    plt.tick_params(left=True, right=False, bottom=True, length=4)
    plt.savefig('plots/PRL/fig2b_kuhn_length_homogenous_1to1000links_0unwraps.pdf')

def plot_kuhns_long_linkers_figb():
    links = np.load('csvs/linker_lengths_homogenous_so_far.npy')
    kuhns = np.load('csvs/kuhns_homogenous_so_far.npy')
    fig, ax = plt.subplots(figsize=(0.7*col_size, 0.42*col_size))
    ax.plot(links, 100 - kuhns, '-o', markersize=1, lw=0.75, color=teal_flucts, label='Chromatin')
    plt.xlabel('Fixed linker length (bp)')
    plt.ylabel('Kuhn length (nm)')
    plt.xscale('log')
    plt.yscale('log')
    plt.legend(loc=4) #lower right
    plt.subplots_adjust(left=0.19, bottom=0.28, top=0.98, right=0.99)
    plt.tick_params(left=True, right=False, bottom=True, length=4)
    #plt.savefig('plots/PRL/kuhn_length_homogenous_1to1000links_0unwraps_power_law.pdf')

def plot_kuhns_multiple_unwraps():
    kuhns = np.load('csvs/kuhns_1to250links_0to146unwraps.npy')
    links = np.arange(1, 251)
    fig, ax = plt.subplots(figsize=(col_size, 0.6*col_size))
    ax.plot(links, kuhns[:, 0], '-o', markersize=1, lw=0.75, color=teal_flucts, label='0 unwraps')
    ax.plot(links, kuhns[:, 21], '-o', markersize=1, lw=0.75, color=red_geom, label='21 unwraps')
    ax.plot(links, kuhns[:, 42], '-o', markersize=1, lw=0.75, color=dull_purple, label='42 unwraps')
    plt.legend()
    plt.xlabel('Fixed linker length (bp)')
    plt.ylabel('Kuhn length (nm)')
    plt.subplots_adjust(left=0.12, bottom=0.25, top=0.98, right=0.98)
    plt.savefig('plots/PRL/kuhn_length_homogenous_multiple_unwraps.pdf')

def plot_kuhn_heterogenous_sigma_47bp(sigmas=np.arange(0, 11), ax=None):
    kuhnsf47 = np.load(f'csvs/r2/kuhns-fluctuations-mu47-sigma_0_10_0unwraps.npy')
    kuhnsg47 = np.load(f'csvs/r2/kuhns-geometrical-mu47-sigma_0_10_0unwraps.npy')
    if ax is None:
        fig, ax = plt.subplots(figsize=(col_size, (5/7)*col_size))
    #entire figure
    ax.plot(sigmas, kuhnsg47, '--^', markersize=4, label='Zero-temperature', color=red_geom)
    ax.plot(sigmas, kuhnsf47, '-o', markersize=4, label='Fluctuations', color=teal_flucts)
    rdf = pd.read_csv('./csvs/r2/r2-fluctuations-exponential-link-mu_47-0unwraps.csv')
    b = rdf['kuhn'].mean()
    xlim = plt.xlim()
    plt.plot([-10, 50], [b, b], 'k-.', label='Maximum Entropy')
    plt.xlim(xlim)
    ax.set_ylim([0, 100])
    plt.legend()
    plt.xlabel('$\sigma$ (bp)')
    plt.ylabel('Kuhn length (nm)')
    plt.subplots_adjust(left=0.14, bottom=0.15, top=0.92, right=0.97)
    plt.savefig('plots/PRL/kuhn_length_vs_sigma_mu47.png')

#plot Green's function for kinked vs. bare WLC
def plot_greens_kinkedWLC_bareWLC(integral, qintegral, links, unwrap, Nvals, rvals=None, rminN1=0.0, qrminN1=0.0):
    """Plot G(R;Rmax) for kinked WLC and bare WLC with same Rmax vs. dimensionless chain length r = R/Rmax,
    one curve per Nval, where N is the chain length in number of nucleosomes.

    Parameters
    ----------
    integral : (rvals.size, Rmax.size) array-like
        Green's function for kinked WLC with this set of linkers and unwrapping
    qintegral : (rvals.size, Rmax.size) array-like
        Green's function for bare WLC with this set of linkers and unwrapping
    links : (L,) array-like
        bare linker length in bp (not including unwrapping)
    unwraps : float
        unwrapping amount in bp. Assumes fixed unwrapping.
    Nvals : array-like
        number of linkers down the chain for which you want to plot G(R;Rmax).
    rminN1 : float
        minimum r value from which the N=1 curve should be plotted for kinked WLC. Due to numerical
        issues, there tends to be noise for r values < 0.7. To avoid plotting this noise,
        set rminN1=0.7 (or whatever value seems fitting for your particular chain).
    qrminN1 : float
        minimum r value for which the N=1 curve should be plotted for bare WLC. e.g. qrminN1=0.7
        Note: hard-coded rmin to be 0.4 for chains of length N=2 because there tends to be noise
        for small r even for the N=2 case.
    """

    if rvals is None:
        rvals = np.linspace(0.0, 1.0, 1000)
    fig, ax = plt.subplots(figsize=(6.17, 4.13))
    ldna = ncg.genomic_length_from_links_unwraps(links, unwraps=unwrap)
    inds = Nvals - 1
    Ls = ldna[inds]

    for ii, i in enumerate(inds):
        color = np.random.rand(3)
        rmin = 0.0
        qrmin = 0.0
        if (i==0): #for N=1 case, don't plot noise
            rmin = rminN1
            qrmin = qrminN1
        if (i==1):
            qrmin = 0.4
        rsub = rvals[(rvals >= rmin)]
        qrsub = rvals[(rvals >= qrmin)]
        intsub = integral[(rvals >= rmin), i]
        qintsub = qintegral[(rvals >= qrmin), i]
        ax.semilogy(rsub, intsub, '-o', markersize=2, linewidth=1,
            color=color, label=f'L={Ls[ii]:.0f}bp, kinked')
        ax.semilogy(qrsub, qintsub, '--', color=color, label=f'L={Ls[ii]:.0f}bp, no kinks')

    ax.legend(frameon=True)
    plt.xlabel('$R/R_{max}$')
    plt.ylabel('G(R;L)')
    #plt.legend([f'L={L:.0f}bp' for L in Ls], frameon=True)
    plt.title(f'{links[0]}bp linkers, {unwrap} unwraps')
    return fig, ax

def plot_old_fig4a(ax=None):
    """The r2 of the 36bp homogenous chain (0 unwrapping) compared to the
    wormlike chain with the corresponding Kuhn length."""
    fig, ax = plt.subplots(figsize=(default_width, default_height))
    rdf = pd.read_csv('./csvs/r2/r2-fluctuations-exponential-link-mu_36-0unwraps.csv')
    try:
        del rdf['Unnamed: 0']
    except:
        pass
    for i, chain in rdf.groupby(['mu', 'chain_id']):
        chain.iloc[0,0] = 1
        chain.iloc[0,1] = 1
        plt.plot(chain['rmax'], chain['r2'], color=dull_purple, alpha=0.4)
        break
    x = np.logspace(0, 7, 100)
    y = wlc.r2wlc(x, rdf['kuhn'].mean()/2)
    plt.plot(x, y, '-', color='k')
    plt.legend([r'$\langle L_i \rangle= 36bp$', r'$WLC, l_p \approx 15 nm$'],
               bbox_to_anchor=(0, 1.02, 1, .102), loc=3, borderaxespad=0)
    for i, chain in rdf.groupby(['mu', 'chain_id']):
        chain.iloc[0,0] = 1
        chain.iloc[0,1] = 1
        plt.plot(chain['rmax'], chain['r2'], color=dull_purple, alpha=0.4)
    plt.plot(x, y, '-', color='k')
    plt.xscale('log')
    plt.yscale('log')
    plt.xlim([0.5, 100000])
    plt.ylim([0.5, 10000000])
    plt.xlabel('Total linker length (nm)')
    plt.ylabel(r'$\sqrt{\langle R^2 \rangle}$')
    plt.savefig('plots/PRL/fig4a_r2_exp_vs_wlc.pdf', bbox_inches='tight')

def draw_power_law_triangle(alpha, x0, width, orientation, base=10,
                            **kwargs):
    """Draw a triangle showing the best-fit power-law on a log-log scale.

    Parameters
    ----------
    alpha : float
        the power-law slope being demonstrated
    x0 : (2,) array_like
        the "left tip" of the power law triangle, where the hypotenuse starts
        (in log units, to be consistent with draw_triangle)
    width : float
        horizontal size in number of major log ticks (default base-10)
    orientation : string
        'up' or 'down', control which way the triangle's right angle "points"
    base : float
        scale "width" for non-base 10

    Returns
    -------
    corner : (2,) np.array
        coordinates of the right-angled corner of the triangle
    """
    x0, y0 = [base**x for x in x0]
    x1 = x0*base**width
    y1 = y0*(x1/x0)**alpha
    plt.plot([x0, x1], [y0, y1], 'k')
    if (alpha >= 0 and orientation == 'up') \
    or (alpha < 0 and orientation == 'down'):
        plt.plot([x0, x1], [y1, y1], 'k')
        plt.plot([x0, x0], [y0, y1], 'k')
        # plt.plot lines have nice rounded caps
        # plt.hlines(y1, x0, x1, **kwargs)
        # plt.vlines(x0, y0, y1, **kwargs)
        corner = [x0, y1]
    elif (alpha >= 0 and orientation == 'down') \
    or (alpha < 0 and orientation == 'up'):
        plt.plot([x0, x1], [y0, y0], 'k')
        plt.plot([x1, x1], [y0, y1], 'k')
        # plt.hlines(y0, x0, x1, **kwargs)
        # plt.vlines(x1, y0, y1, **kwargs)
        corner = [x1, y0]
    else:
        raise ValueError(r"Need $\alpha\in\mathbb{R} and orientation\in{'up', 'down'}")
    return corner

def plot_looping_heterogeneous(df=None, rmax_or_ldna='ldna', named_sim='links31-to-52'):
    "Plot supplemental looping figure with uniformly distributed linkers 31-52 bp."
    fig, ax = plt.subplots(figsize=(default_width, default_height))
    n = rmax_or_ldna
    # first set sim-specific parameters, draw scaling triangles at manually
    # chosen locations
    if (named_sim, rmax_or_ldna) == ('mu56', 'ldna'):
        draw_power_law_triangle(-3/2, x0=[3.8, -7.1], width=0.4, orientation='up')
        plt.text(10**(3.95), 10**(-6.8), '$L^{-3/2}$')
        # manually set thresholds to account for numerical instability at low n
        min_n = 10**2.6
    elif (named_sim, rmax_or_ldna) == ('mu56', 'rmax'):
        draw_power_law_triangle(-3/2, x0=[3.0, -7.5], width=0.4, orientation='up')
        plt.text(10**3.1, 10**(-7.3), '$L^{-3/2}$')
        min_n = 10**2.2
    elif (named_sim, rmax_or_ldna) == ('links31-to-52', 'rmax'):
        draw_power_law_triangle(-3/2, x0=[3.0, -7.5], width=0.4, orientation='up')
        plt.text(10**3.1, 10**(-7.3), '$L^{-3/2}$')
        min_n = 10**2.0
    elif (named_sim, rmax_or_ldna) == ('links31-to-52', 'ldna'):
        draw_power_law_triangle(-3/2, x0=[3.5, -7], width=0.4, orientation='up')
        plt.text(10**3.6, 10**(-6.8), '$L^{-3/2}$')
        min_n = 10**2.5
    if df is None:
        df = load_looping_statistics_heterogenous_chains(named_sim=named_sim)
    # if the first step is super short, we are numerically unstable
    df.loc[df['rmax'] <= 5, 'ploops'] = np.nan
    # if the output is obviously bad numerics, ignore it
    df.loc[df['ploops'] > 10**(-4), 'ploops'] = np.nan
    df.loc[df['ploops'] < 10**(-13), 'ploops'] = np.nan
    df = df.dropna()
    df = df.sort_values(n)
    df_int = df.groupby(['num_nucs', 'chain_id']).apply(interpolated_ploop,
            rmax_or_ldna=rmax_or_ldna, n=np.logspace(np.log10(min_n), np.log10(df[n].max()), 1000))
    df_int_ave = df_int.groupby(n+'_interp')['ploops_interp'].agg(['mean', 'std', 'count'])
    df_int_ave = df_int_ave.reset_index()
    xgrid = df_int_ave[n+'_interp'].values
    y_pred = df_int_ave['mean'].values
    sig = df_int_ave['std'].values/np.sqrt(df_int_ave['count'].values - 1)
    # 95% joint-confidence intervals, bonferroni corrected
    ste_to_conf = scipy.stats.norm.ppf(1 - (0.05/1000)/2)
    # plot all the individual chains, randomly chop some down to make plot look
    # nicer
    palette = sns.cubehelix_palette(n_colors=len(df.groupby(['num_nucs', 'chain_id'])))
    ord = np.random.permutation(len(palette))
    for i, (label, chain) in enumerate(df.groupby(['num_nucs', 'chain_id'])):
        num_nucs = int(label[0])
        max_nuc_to_plot = num_nucs*(1 - 0.2*np.random.rand())
        chain = chain[chain['nuc_id'] <= max_nuc_to_plot]
        chain = chain[chain[n] >= min_n]
        plt.plot(chain[n].values, chain['ploops'].values,
                 c=palette[ord[i]], alpha=0.15, lw=0.5, label=None)
    # bold a couple of the chains
    bold_c = palette[int(9*len(palette)/10)]
    if named_sim == 'mu56':
        chains_to_bold = [(100,1), (50,120), (100,112)]
    elif named_sim == 'links31-to-52':
        chains_to_bold = [(50, 1), (50, 3), (50, 5)]
    for chain_id in chains_to_bold:
        chain = df.loc[chain_id]
        chain = chain[chain[n] >= min_n]
        plt.plot(chain[n].values, chain['ploops'].values, c=bold_c, alpha=0.6,
                 label=None)
    fill = plt.fill_between(xgrid,
            y_pred - ste_to_conf*sig,
            y_pred + ste_to_conf*sig,
            alpha=.10, color='r')

    plt.plot(xgrid, y_pred, 'r-', label='Average $\pm$ 95\%')

    # load in the straight chain, in [bp] (b = 100nm/ncg.dna_params['lpb'])
    bare_n, bare_ploop = wlc.load_WLC_looping()
    # now rescale the straight chain to match average
    if named_sim == 'mu56':
        b = 40.67 # nm
        k = b/100 # scaling between straight and 56bp exponential chain
        nn = 146/56 # wrapped amount to linker length ratio
    elif named_sim == 'links31-to-52':
        b = 2*13.762 # nm
        k = b/100 # scaling between straight and uniform chain
        nn = 146/41.5
    if rmax_or_ldna == 'ldna':
        # we use the fact that (e.g. for exp_mu56, 0 unwraps)
        # df['ldna'] = df['rmax'] + 146*df['nuc_id']
        # (on ave)   = df['rmax'] + 146*df['rmax']/56
        bare_n = bare_n*(1 + nn)
    x, y = bare_n*k, bare_ploop/k**3,
    lnormed = plt.plot(x[x >= min_n], y[x >= min_n],
                       'k-.', label=f'Straight chain, b={b:0.1f}nm')
    # also plot just the bare WLC
    b = 2*wlc.default_lp
    min_n_b100 = 10**2.7
    l100 = plt.plot(bare_n[bare_n>=min_n_b100], bare_ploop[bare_n>=min_n_b100], '-.', c=teal_flucts,
             label=f'Straight chain, b=100nm')
    # plt.plot(bare_n, wlc.sarah_looping(bare_n/2/wlc.default_lp)/(2*wlc.default_lp)**2)

    plt.xlim([10**(np.log10(min_n)*1), 10**(np.log10(np.max(df[n]))*0.99)])
    if rmax_or_ldna == 'rmax':
        plt.ylim([10**(-11), 10**(-6)])
    elif rmax_or_ldna == 'ldna':
        plt.ylim([10**(-13), 10**(-5)])
    plt.tick_params(axis='y', which='minor', left=False)

    if rmax_or_ldna == 'rmax':
        plt.xlabel('Total linker length (bp)')
    elif rmax_or_ldna == 'ldna':
        plt.xlabel('Genomic distance (bp)')
    plt.ylabel(r'$P_\mathrm{loop}\;\;\;(\mathrm{nm}^{-3})$')

    # plt.legend([fill, l100, lnormed], ['Average $\pm$ 95\%',
    #         'Straight chain, b=100nm', f'Straight chain, b={b:0.2f}nm'],
    plt.legend(loc='upper right', bbox_to_anchor=[0.9, 0.35])
    plt.yscale('log')
    plt.xscale('log')

    plt.tight_layout()
    plt.savefig(f'plots/PRL/figS8_{named_sim}_{rmax_or_ldna}.pdf', bbox_inches='tight')

def interpolated_ploop(df, rmax_or_ldna='ldna', n=np.logspace(2, 5, 1000),
                       ploop_col='ploops'):
    """Function to apply to the looping probabilities of a given chain to
    resample it to a fixed set of values."""
    n_col = rmax_or_ldna
    n = n[(n >= df[n_col].min()) & (n <= df[n_col].max())]
    ploop = np.interp(n, df[n_col].values, df[ploop_col].values,
            left=df[ploop_col].values[0], right=df[ploop_col].values[-1])
    return pd.DataFrame(np.stack([n, ploop]).T, columns=[n_col+'_interp', ploop_col+'_interp'])


def figs11a_unwrapping_kuhn():
    """ to generate the data needed to make this plot, run r2-tabulation.py
    with kd_unwrap equal to the values below, and mu=np.arange(100) """
    fig, ax = plt.subplots(figsize=(1.1*default_width, default_height))

    kuhns_file = Path('csvs/kuhns-kd_unwrap.csv')
    if kuhns_file.exists():
        kuhns = pd.read_csv(kuhns_file) \
                .set_index(['variance_type', 'sim_type']) \
                .apply(pd.to_numeric)
    else:
        prefix = 'r2-fluct-exp-mu_*-sigma_0-kd_unwraps_'
        # globs = [prefix + name for name in ['1e-10-small.csv', '0.1-small.csv',
        #                                     '0.01-small.csv', '0.001-small.csv']]
        globs = [prefix + name for name in ['0-fake_kd.csv', '0.1-small.csv',
                                            '0.01-small.csv', '0.001-small.csv']]
        kuhns = pd.concat([wlc.aggregate_existing_kuhns(glob) for glob in globs]) \
                .reset_index() \
                .set_index(['variance_type', 'sim_type']) \
                .apply(pd.to_numeric) \
                .sort_values('mu')
    kd = 0
    ks = kuhns[kuhns['kd_unwrap'] == 0]
    plt.scatter(ks['mu'], ks['b'], s=2, c='k', label=f'$K_d = {kd}$')
    kds = [0.1, 0.01, 0.001]
    for i, kd in enumerate(kds):
        ks = kuhns[kuhns['kd_unwrap'] == kd]
        plt.scatter(ks['mu'], ks['b'], c=sns.color_palette()[i],
                 label=f'$K_d = {kd}$', alpha=0.7)
    plt.legend()
    kd = 0
    ks = kuhns[kuhns['kd_unwrap'] == 0]
    plt.scatter(ks['mu'], ks['b'], s=2, c='k')
    plt.plot(ks['mu'], ks['b'], c='k')

    plt.xlabel(r'$\langle L_i \rangle$')
    plt.ylabel(r'Kuhn length (nm of linker)')
    # for i, kd in enumerate(kds):
    #     ks = kuhns[kuhns['kd_unwrap'] == kd]
    #     plt.plot(ks['mu'], ks['b'], c=sns.color_palette()[i],
    #              alpha=0.1
    plt.savefig(f'plots/PRL/figS11_unwrapping_kuhns.pdf', bbox_inches='tight')
    return kuhns

def figs11b_unwrapping_levels():
    fig, ax = plt.subplots(figsize=(default_width*0.4, 0.5*default_height))
    x = np.arange(8)
    kds = [0.1, 0.01, 0.001]
    for i, kd in enumerate(kds):
        plt.bar(x, scipy.stats.binom(7, kd).pmf(x),
                fc=sns.color_palette()[i]+(0.3,), width=1,
                ec=sns.color_palette()[i], linewidth=2,
                label=f'$K_d = {kd}$')
    xticks = [0, 2, 4, 6]
    plt.xticks(xticks)
    plt.xlabel(r'# unwrapped')
    plt.ylabel(r'Probability')
    plt.savefig(f'plots/PRL/figS11_unwrapping_levels.pdf', bbox_inches='tight')

