#plotting parameters
import matplotlib.cm as cm
import numpy as np
import seaborn as sns
import pandas as pd
from matplotlib import pyplot as plt
import scipy
from scipy import stats
from scipy.optimize import curve_fit
from nuc_chain import geometry as ncg
from nuc_chain import linkers as ncl
from MultiPoint import propagator
from nuc_chain import fluctuations as wlc
from nuc_chain.linkers import convert
from mpl_toolkits.axes_grid1 import make_axes_locatable

# Plotting parameters
# PRL Font preference: computer modern roman (cmr), medium weight (m), normal shape
cm_in_inch = 2.54
# column size is 8.6 cm
col_size = 8.6 / cm_in_inch

#These follow Andy's plotting preferences for
medium_params = {
    'axes.edgecolor': 'black',
    'axes.grid': False,
    'axes.titlesize': 8.0,

    'axes.linewidth': 0.75,
    'backend': 'pdf',
    'axes.labelsize': 8.5,
    'legend.fontsize': 8,

    'xtick.labelsize': 7,
    'ytick.labelsize': 7,
    'text.usetex': False,
    'figure.figsize': [col_size, col_size*(5/7)],

    'font.family': 'sans-serif',
    'font.sans-serif': 'Arial',

    'mathtext.fontset': 'stixsans',
    'savefig.format': 'pdf',
    'xtick.bottom':True,
    'xtick.major.pad': 2,
    'xtick.major.size': 4,
    'xtick.major.width': 0.5,

    'ytick.left':True,
    'ytick.right':False,
    'ytick.major.pad': 2,
    'ytick.major.size': 4,
    'ytick.major.width': 0.5,
    'ytick.minor.right':False,
    'lines.linewidth':1
}
plt.rcParams.update(medium_params)
teal_flucts = '#387780'
red_geom = '#E83151'
dull_purple = '#755F80'
Klin = np.linspace(0, 10**5, 20000)
Klog = np.logspace(-3, 5, 10000)
Ks = np.unique(np.concatenate((Klin, Klog)))
#Kprops = wlc.tabulate_bareWLC_propagators(Ks)

#compare linker propagators generated by ODE solver vs. Quinn/Shafiq's partial fractions solution in Laplace space
def calculate_GKN_Quinn_vs_Deepti(l, l0, j, Ks=Ks, Ns=np.array([0.1, 1.0, 10, 100])):
    """Plotting code for G(K;N) vs K for a given l, l0, j. Plots one curve for each N."""

    Gs = np.zeros((Ns.size, Ks.size), 'complex')
    qGs = np.zeros((Ns.size, Ks.size), 'complex')
    for nn in range(Ns.size):
        for kk in range(Ks.size):
            qGs[nn, kk] = Kprops[kk].get_G(Ns[nn], l0, l)
            Gs[nn, kk] = wlc.get_G(Ks[kk], Ns[nn], l, l0, j)
        ax.loglog(Ks, np.abs(Gs[nn, :].real), color = colors[nn], label='ODE solution')
        ax.loglog(Ks, np.abs(qGs[nn, :].real), '--', color = colors[nn], label='Laplace solution')
        ax.loglog(Ks, np.sin(Ks*Ns[nn])/(Ks*Ns[nn]), ':', color = colors[nn], label='sin(KN)/(KN)')

    ax.legend(frameon=True)
    plt.xlabel('K')
    plt.ylabel('G(K;N)')
    plt.title(f'$l={l}, l_0={l0}, j={j}$')
    plt.legend([f'N={N}' for N in Ns])
    plt.ylim([10**-12, 2])
    plt.show()
    return Gs

def plot_GKN_Quinn_vs_Deepti(Ks=Ks, Ns=np.array([0.1, 1.0, 10, 100])):
    fig, ax = plt.subplots(figsize=(7.21, 5.19))
    colors = sns.color_palette()
    for nn in range(Ns.size):
        ax.loglog(Ks, Gs[nn, :].real, color = colors[nn], label=f'N={Ns[nn]}, ODE')
        ax.loglog(Ks, qGs[nn, :].real, '--', color = colors[nn], label=f'N={Ns[nn]}, Laplace')

    plt.legend(fontsize=14)
    plt.xlabel('K')
    plt.ylabel('G(K;N)')
    plt.title(f'$l={l}, l_0={l0}, j={j}$')
    plt.ylim([10**-8, 2])
    plt.xlim([10**-3, 10**4])
    plt.subplots_adjust(left=0.15, bottom=0.16, top=0.91, right=0.95)
    plt.savefig('plots/props/GKN_quinnWLC_vs_deeptiWLC_linker_prop.png')

def plot_GKN_rigid_rod_vs_kinked(Ks=Ks, Ns=np.array([0.1, 1.0, 10])):
    """Plotting code for G(K;N) vs K for a given l, l0, j. Plots one curve for each N."""
    fig, ax = plt.subplots(figsize=(7.21, 5.19))
    colors = sns.color_palette()
    for nn in range(3):
        ax.loglog(Ks, Gs[nn, :].real, color = colors[nn], label=f'N={Ns[nn]}, ODE solution')
        ax.loglog(Ks, np.sin(Ks*Ns[nn])/(Ks*Ns[nn]), ':', color = colors[nn], label=f'N={Ns[nn]}, sin(KN)/(KN)')

    plt.legend(fontsize=14)
    plt.xlabel('K')
    plt.ylabel('G(K;N)')
    plt.title(f'$l={l}, l_0={l0}, j={j}$')
    plt.ylim([10**-8, 2])
    plt.xlim([10**-3, 10**4])
    plt.subplots_adjust(left=0.15, bottom=0.16, top=0.91, right=0.95)
    plt.savefig('plots/props/GKN_rigid_rod_vs_deeptiWLC_linker_prop.png')

def plot_kuhns_long_linkers_figa():
    links = np.load('csvs/linker_lengths_homogenous_so_far.npy')
    kuhns = np.load('csvs/kuhns_homogenous_so_far.npy')
    fig, ax = plt.subplots(figsize=(0.7*col_size, 0.42*col_size))
    ax.plot(links, kuhns, '-o', markersize=1, lw=0.75, color=teal_flucts, label='Chromatin')
    ax.plot(np.linspace(min(links), max(links), 1000), np.tile(100, 1000), '--', lw=0.75, label='Bare DNA', color=dull_purple)
    plt.xlabel('Fixed linker length (bp)')
    plt.ylabel('Kuhn length (nm)')
    plt.xscale('log')
    plt.legend(loc=4) #lower right
    plt.subplots_adjust(left=0.19, bottom=0.28, top=0.98, right=0.99)
    plt.tick_params(left=True, right=False, bottom=True, length=4)
    plt.savefig('plots/PRL/fig2b_kuhn_length_homogenous_1to1000links_0unwraps.pdf')

def plot_kuhns_long_linkers_figb():
    links = np.load('csvs/linker_lengths_homogenous_so_far.npy')
    kuhns = np.load('csvs/kuhns_homogenous_so_far.npy')
    fig, ax = plt.subplots(figsize=(0.7*col_size, 0.42*col_size))
    ax.plot(links, 100 - kuhns, '-o', markersize=1, lw=0.75, color=teal_flucts, label='Chromatin')
    plt.xlabel('Fixed linker length (bp)')
    plt.ylabel('Kuhn length (nm)')
    plt.xscale('log')
    plt.yscale('log')
    plt.legend(loc=4) #lower right
    plt.subplots_adjust(left=0.19, bottom=0.28, top=0.98, right=0.99)
    plt.tick_params(left=True, right=False, bottom=True, length=4)
    #plt.savefig('plots/PRL/kuhn_length_homogenous_1to1000links_0unwraps_power_law.pdf')

def plot_kuhns_multiple_unwraps():
    kuhns = np.load('csvs/kuhns_1to250links_0to146unwraps.npy')
    links = np.arange(1, 251)
    fig, ax = plt.subplots(figsize=(col_size, 0.6*col_size))
    ax.plot(links, kuhns[:, 0], '-o', markersize=1, lw=0.75, color=teal_flucts, label='0 unwraps')
    ax.plot(links, kuhns[:, 21], '-o', markersize=1, lw=0.75, color=red_geom, label='21 unwraps')
    ax.plot(links, kuhns[:, 42], '-o', markersize=1, lw=0.75, color=dull_purple, label='42 unwraps')
    plt.legend()
    plt.xlabel('Fixed linker length (bp)')
    plt.ylabel('Kuhn length (nm)')
    plt.subplots_adjust(left=0.12, bottom=0.25, top=0.98, right=0.98)
    plt.savefig('plots/PRL/kuhn_length_homogenous_multiple_unwraps.pdf')

def plot_kuhn_heterogenous_sigma_47bp(sigmas=np.arange(0, 11), ax=None):
    kuhnsf47 = np.load(f'csvs/r2/kuhns-fluctuations-mu47-sigma_0_10_0unwraps.npy')
    kuhnsg47 = np.load(f'csvs/r2/kuhns-geometrical-mu47-sigma_0_10_0unwraps.npy')
    if ax is None:
        fig, ax = plt.subplots(figsize=(col_size, (5/7)*col_size))
    #entire figure
    ax.plot(sigmas, kuhnsg47, '--^', markersize=4, label='Geometrical', color=red_geom)
    ax.plot(sigmas, kuhnsf47, '-o', markersize=4, label='Fluctuations', color=teal_flucts)
    rdf = pd.read_csv('./csvs/r2/r2-fluctuations-exponential-link-mu_47-0unwraps.csv')
    b = rdf['kuhn'].mean()
    xlim = plt.xlim()
    plt.plot([-10, 50], [b, b], 'k-.', label='Maximum Entropy')
    plt.xlim(xlim)
    ax.set_ylim([0, 100])
    plt.legend()
    plt.xlabel('$\sigma$ (bp)')
    plt.ylabel('Kuhn length (nm)')
    plt.subplots_adjust(left=0.14, bottom=0.15, top=0.92, right=0.97)
    plt.savefig('plots/PRL/kuhn_length_vs_sigma_mu47.png')

#plot Green's function for kinked vs. bare WLC
def plot_greens_kinkedWLC_bareWLC(integral, qintegral, links, unwrap, Nvals, rvals=None, rminN1=0.0, qrminN1=0.0):
    """Plot G(R;Rmax) for kinked WLC and bare WLC with same Rmax vs. dimensionless chain length r = R/Rmax,
    one curve per Nval, where N is the chain length in number of nucleosomes.

    Parameters
    ----------
    integral : (rvals.size, Rmax.size) array-like
        Green's function for kinked WLC with this set of linkers and unwrapping
    qintegral : (rvals.size, Rmax.size) array-like
        Green's function for bare WLC with this set of linkers and unwrapping
    links : (L,) array-like
        bare linker length in bp (not including unwrapping)
    unwraps : float
        unwrapping amount in bp. Assumes fixed unwrapping.
    Nvals : array-like
        number of linkers down the chain for which you want to plot G(R;Rmax).
    rminN1 : float
        minimum r value from which the N=1 curve should be plotted for kinked WLC. Due to numerical
        issues, there tends to be noise for r values < 0.7. To avoid plotting this noise,
        set rminN1=0.7 (or whatever value seems fitting for your particular chain).
    qrminN1 : float
        minimum r value for which the N=1 curve should be plotted for bare WLC. e.g. qrminN1=0.7
        Note: hard-coded rmin to be 0.4 for chains of length N=2 because there tends to be noise
        for small r even for the N=2 case.
    """

    if rvals is None:
        rvals = np.linspace(0.0, 1.0, 1000)
    fig, ax = plt.subplots(figsize=(6.17, 4.13))
    ldna = ncg.genomic_length_from_links_unwraps(links, unwraps=unwrap)
    inds = Nvals - 1
    Ls = ldna[inds]

    for ii, i in enumerate(inds):
        color = np.random.rand(3)
        rmin = 0.0
        qrmin = 0.0
        if (i==0): #for N=1 case, don't plot noise
            rmin = rminN1
            qrmin = qrminN1
        if (i==1):
            qrmin = 0.4
        rsub = rvals[(rvals >= rmin)]
        qrsub = rvals[(rvals >= qrmin)]
        intsub = integral[(rvals >= rmin), i]
        qintsub = qintegral[(rvals >= qrmin), i]
        ax.semilogy(rsub, intsub, '-o', markersize=2, linewidth=1,
            color=color, label=f'L={Ls[ii]:.0f}bp, kinked')
        ax.semilogy(qrsub, qintsub, '--', color=color, label=f'L={Ls[ii]:.0f}bp, no kinks')

    ax.legend(frameon=True)
    plt.xlabel('$R/R_{max}$')
    plt.ylabel('G(R;L)')
    #plt.legend([f'L={L:.0f}bp' for L in Ls], frameon=True)
    plt.title(f'{links[0]}bp linkers, {unwrap} unwraps')
    return fig, ax





def plot_old_fig4a(ax=None):
    """The r2 of the 36bp homogenous chain (0 unwrapping) compared to the
    wormlike chain with the corresponding Kuhn length."""
    fig, ax = plt.subplots(figsize=(default_width, default_height))
    rdf = pd.read_csv('./csvs/r2/r2-fluctuations-exponential-link-mu_36-0unwraps.csv')
    try:
        del rdf['Unnamed: 0']
    except:
        pass
    for i, chain in rdf.groupby(['mu', 'chain_id']):
        chain.iloc[0,0] = 1
        chain.iloc[0,1] = 1
        plt.plot(chain['rmax'], chain['r2'], color=dull_purple, alpha=0.4)
        break
    x = np.logspace(0, 7, 100)
    y = wlc.r2wlc(x, rdf['kuhn'].mean()/2)
    plt.plot(x, y, '-', color='k')
    plt.legend([r'$\langle L_i \rangle= 36bp$', r'$WLC, l_p \approx 15 nm$'],
               bbox_to_anchor=(0, 1.02, 1, .102), loc=3, borderaxespad=0)
    for i, chain in rdf.groupby(['mu', 'chain_id']):
        chain.iloc[0,0] = 1
        chain.iloc[0,1] = 1
        plt.plot(chain['rmax'], chain['r2'], color=dull_purple, alpha=0.4)
    plt.plot(x, y, '-', color='k')
    plt.xscale('log')
    plt.yscale('log')
    plt.xlim([0.5, 100000])
    plt.ylim([0.5, 10000000])
    plt.xlabel('Total linker length (nm)')
    plt.ylabel(r'$\sqrt{\langle R^2 \rangle}$')
    plt.savefig('plots/PRL/fig4a_r2_exp_vs_wlc.pdf', bbox_inches='tight')


