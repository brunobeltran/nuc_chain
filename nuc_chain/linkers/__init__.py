"""Generate linker lengths and distributional quantities about them.

For use with nuc_chain.chain to produce realizations of nucleosome chains.

All linker lengths generated are distances between the last bound base of the
prev nucleosome and the first bound base of the next one. In order to get
dyad-to-dyad distances, the relevant amount of bound base pairs w_in(i+1) +
w_out(i) must be added.
"""
import scipy
import scipy.stats
import numpy as np

from .. import bp_in_nuc

default_chrom_size = 20000000

def independent_linker_lengths(mu, size, chrom_size=default_chrom_size,
        bp_in_nuc=bp_in_nuc):
    """Generate linker lengths via binding the right number of nucleosomes to a
    chromosome (including sterics) uniformly so that the average spacing
    matches a given average linker length.

    Parameters
    ----------
    mu : int
        average linker length. must be integer for now due to generation
        algorithm
    size : array_like
        shape of output linker lengths array
    chrom_size : int
        number of base pairs in the chromosome of interest. for the same reason
        as in mu, this will be rounded so that an integer number of nucleosomes
        fit exactly into it??? - not sure why
    bp_in_nuc : int
        number of base pair lengths (so # bound bp - 1) wrapped around
        nucleosome


    Notes
    -----
    Plots in :/plots/linkers show that the lattice gas model produces more
    or less exponential linker lengths with no apparent autocorrlation
    structure.

    This is the same thing you would get if you just had m binders on a lattice
    of length n (which would give mean linker length of m/n).

    Therefore, to generate the exponentially distributed lengths, a real
    "chromosome" of the requested size is created, and the numbers generated by
    actually binding the nucleosomes at specific locations accounting for
    sterics, to account for the "finite size" and "integer rounding of
    exponentials" issues.

    For most applications, the chromosome size won't matter since the
    distribution quickly becomes almost exactly exponential, so we allow a
    default chromosome size of 20Mb.
    """
    if chrom_size < 10000:
        raise NotImplementedError("The approximation made here is only valid for large chrom_size. mu must be renormalized to account for small-lattice-size effects.  Otherwise you won't get out the same mu as you requested.")
    # nucleosomes will take up some fraction of the space
    bp_per_nuc = mu + bp_in_nuc
    num_nuc = int(np.round(chrom_size / bp_per_nuc))
    # if rounding the chrom_size so that it's an even division causes too much
    # error, alert the user
    new_chrom_size = num_nuc*bp_per_nuc
    if np.abs(new_chrom_size - chrom_size)/chrom_size > 0.0001:
        raise ValueError("Rounding chrom_size so that an integer number of nucleosomes can fit on the chromosome changes the genome size by more than 0.01%.")
    chrom_size = new_chrom_size
    # if we're going to insert num_nuc things of size bp_in_nuc into a
    # lattice of size chrom_size, that's exactly equivalent to inserting
    # without repetition into a smaller lattice things of size 0...
    # basically we just need a lattice such that the lattice_size divided
    # by the number of points we're inserting into it equals the requested
    # mean spacing mu
    #TODO to allow for non-integer mu, we need to think carefully about whether
    # just lattice size or also the number of nucleosomes should be dynamically
    # changing so that the ensemble gets the correct fraction. as below, maybe
    # inspecting the random_positions_in_lattice and modifying it slightly
    # might be the easiest way instead.
    lattice_size = mu*num_nuc
    if int(lattice_size) != lattice_size:
        raise ValueError("Only integer average spacing allowed.")
    # generate the linkers as many as possible at a time
    #TODO rescale problem cleverly so that this still works quickly if you
    # only want a couple of linkers and get a huge num_nuc
    # probably just a single call to random_positions_in_lattice should work or
    # maybe inspecting that code and modifying it appropriately...
    total_linkers = np.prod(size)
    linkers = np.zeros((total_linkers,))
    i = 0
    while i < total_linkers:
        positions = np.random.randint(lattice_size, size=(num_nuc,))
        positions.sort()
        # if we wanted to exclude linkers of size zero (but we don't) we would
        # instead use
        #positions = random_positions_in_lattice(num_nuc, lattice_size)
        remaining_linkers = total_linkers - i
        linkers[i:i+num_nuc-1] = np.diff(positions)[:remaining_linkers]
        i = i + num_nuc - 1
    return np.reshape(linkers, size)

def random_positions_in_lattice(count, lattice_size):
    """Insert n steric objects (of width 1) into a discrete lattice of
    lattice_size (uniform potential of insertion).

    Equivalent to np.sort(np.random.shuffle(np.arange(lattice_size)))[:n]

    Notes
    -----
    Translated from the following code on stack overflow
    (https://stackoverflow.com/questions/16000196/java-generating-non-repeating-random-numbers)
    from the book "programming pearls" pg 127.
    public static int[] sampleRandomNumbersWithoutRepetition(int start, int end, int count) {
        Random rng = new Random();

        int[] result = new int[count];
        int cur = 0;
        int remaining = end - start;
        for (int i = start; i < end && count > 0; i++) {
            double probability = rng.nextDouble();
            if (probability < ((double) count) / (double) remaining) {
                count--;
                result[cur++] = i;
            }
            remaining--;
        }
        return result;
    }
    """
    result = np.zeros((count,))
    cur = 0
    remaining = lattice_size
    i = 0
    while True:
        if np.random.rand() < float(count)/float(remaining):
            count -= 1
            result[cur] = i
            cur += 1
        remaining -= 1
        if not (i < lattice_size and count > 0):
            break
        i += 1
    return result

def fake_linkers_increasing_variance(mu, sigma, size, type='lognorm'):
    """Generate "linkers" that are only designed to be used to test the
    properties of heterogenous nucleosome chains, and not necessarily to
    actually replicate anything biological.

    Several methods can be used here, all are parameterized by their mean and
    variance in linker lengths.

    type='gamma'
    The actual linker lengths distribution is probably something like an
    expnential, but since an exponential distribution cannot be given differnet
    variance if the mean is fixed, we instead use gamma distributed numbers
    with shape and scale parameters varied so that the mean stays constant (at
    the given mu=mean linker length) and the variance changes as requested. we
    arbitrarily choose the interept with the exponential distribution (shape=1)
    to be when the variance is one (scale=1)

    type='lognorm'
    Much simpler, no connection to reality. Just a lognormal distribution with
    mean of mu and variance of sigma.

    type='box'
    Even simpler. mu is the average linker length, and sigma is the number of
    linker lengths on each side of it to include. so for example mu=36, sigma=1
    would give linkers uniformly chosen from [35, 36, 37].
    """
    if np.isclose(sigma, 0):
        return mu*np.ones(size)
    if type == 'gamma':
        raise NotImplementedError('See docstring for intended implementation.')
    elif type == 'lognorm':
        # the mean adn variance of X, the normal variable such that the lognorm
        # variable Y that we want to compute is Y = exp(X), from wiki
        norm_mu = np.log(mu/np.sqrt(1 + (sigma/mu)**2))
        norm_sigma = np.sqrt(np.abs(np.log(1 + (sigma/mu)**2)))
        return scipy.stats.lognorm(s=norm_sigma, scale=np.exp(norm_mu)).rvs(size=size)
    elif type == 'box':
        choices = np.arange(mu - sigma, mu + sigma + 1)
        n = len(choices)
        i = np.random.randint(n, size=size)
        return choices[i]

