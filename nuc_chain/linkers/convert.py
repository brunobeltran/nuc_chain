from .. import * # default parameters
import numpy as np
import pandas as pd

def resolve_unwrap(unwrap, unwraps_is='bp'):
    """Allows the user to specify number of base pairs unwrapped compared to
    the crystal structure (146bp of DNA length wrapped, 147bp bound since one
    base pair is exactly on the dyad axis), and converts this to the number of
    base pairs bound on each side of the dyad axis.

    Optionally, the user can specify an alternate model "sites" for DNA
    unwrapping, where the 7 nucleosome-DNA contact "sites" on each side of the
    dyad axis are treated explicitly. These contact locations are known to
    occur every 10.5bp, and the dyad is centered between two of them. this
    means that the 14 contact points have 13 lengths of DNA (of length 10.5bp)
    between them, leading to a total wrapped amount (with both sites bound) of
    about 13*10.5 = 136.5bp.

    This means 0 sites unwrapped corresponds to 10.5bp unwrapped.

    The w_in+w_out value will be rounded, due to our codebase only
    precomputing the linker propagator for integer unwrapping amounts by
    default.

    Parameters
    ----------
    unwrap : int
        total amount of unwrapped DNA on both sides
    unwraps_is : string
        'bp' or 'sites', specifies the DNA-nucleosome binding model used

    Returns
    -------
    w_in : int
        amount wrapped entry side of dyad axis
    w_out : int
        amount wrapped exit side of dyad axis
    """
    if unwraps_is == 'sites':
        unwrap = 10.5 + 10.5*unwrap
    unwrap = np.round(unwrap).astype(int)
    if unwrap % 2 == 1:
        w_in = (bp_in_nuc - unwrap)/2
        return w_in, w_in-1
    else:
        w = (bp_in_nuc - unwrap - 1)/2
        return w, w
    return

def resolve_wrapping_params(unwraps, w_ins=None, w_outs=None, N=None, unwraps_is='bp'):
    """Allow the user to specify either one value (and tile appropriately) or
    an array of values for the number of base pairs bound to the nucleosome.
    Also allow either the number of base pairs bound on each side of the dyad to be
    specified or the number of base pairs unwrapped relative to the crystal
    structure (in which case the unwrapping is split evenly on either side of
    the dyad for simplicity.

    Parameters
    ----------
    unwraps : float or (N,) array_like
        total amount of unwrapped DNA on both sides
    w_ins (optional): float or (N,) array_like
        wrapped DNA on entry side of dyad axis
    w_outs (optional): float or (N,) array_like
        wrapped DNA on exit side of dyad axis
    N (optional): int
        output size, if other params are not array_like
    unwraps_is : string
        'bp' or 'sites', to specify whether we're counting the number of bp
        bound or the number of nucleosome-to-dna contacts (respectively)

    Returns
    -------
    w_in : (N,) np.ndarray
        N output wrapping lengths on entry side of dyad axis
    w_out : (N,) np.ndarray
        N output wrapping lengths on exit side of dyad axis

    All functions take w_in, w_out directly now."""
    if (w_ins is None) != (w_outs is None):
        raise ValueError("Either none or both of w_in and w_out must be specified.")

    if unwraps is not None:
        unwraps = np.atleast_1d(unwraps)
        w_ins, w_outs = zip(*map(resolve_unwrap, unwraps))
    w_ins = np.atleast_1d(w_ins)
    w_outs = np.atleast_1d(w_outs)
    if len(w_ins) == 1 and N is not None:
        w_ins = np.tile(w_ins, (N,))
        w_outs = np.tile(w_outs, (N,))
    return w_ins, w_outs


def links_from_dyad_locations(filename, w_ins=default_w_in, w_outs=default_w_out,
                                        helix_params=helix_params_best, unwraps=None):
    """Extract linker lengths from a list of dyad locations generated by Bruno's
    nucleosome positioning code. Calculate gprops for these linkers and save.

    Parameters
    ----------
    filename : str, pathlib.Path
        file name or path to csv file with 2 columns: 'nucleosome rank', 'dyad location (bp)'
    w_ins : float or (L+1,) array_like
        amount of DNA wrapped on entry side of central dyad base in bp
    w_outs : float or (L+1,) array_like
        amount of DNA wrapped on exit side of central dyad base in bp
    unwraps: float or (L+1,) array-like
        total amount of DNA unwrapped on both sides of nucleosome in bp

    Returns
    -------
    links : (L,) array-like
        set of bare linker lengths, one for each row in inputted csv
    """

    df = pd.read_csv(filename, header=0, names=['nuc', 'dyad_location'])
    b = helix_params['b']
    num_linkers = df.shape[0] #rows give dyad positions
    w_ins, w_outs = resolve_wrapping_params(unwraps, w_ins, w_outs, num_linkers+1)
    # calculate unwrapping amounts based on w_ins and w_outs
    mu_ins = (b - 1)/2 - w_ins
    mu_outs = (b - 1)/2 - w_outs

    links = np.zeros((num_linkers,))
    dyad_to_dyad_distances = np.diff(df.dyad_location)

    for i, dyad_to_dyad in enumerate(dyad_to_dyad_distances):
        #bare linker length is dyad_to_dyad distance minus wrapped and unwrapped amounts
        links[i] = dyad_to_dyad - w_outs[i] - mu_outs[i] - mu_ins[i+1] - w_ins[i+1]

    return links


def genomic_length_from_links_unwraps(links, w_ins=default_w_in, w_outs=default_w_out,
                            helix_params=helix_params_best, unwraps=None):
    """Returns cumulative chain length as a function of the number of monomers along nucleosome chain,
    where each monomer is dyad-to-dyad and includs the wrapped bp on exit side of first nucleosome,
    unwrapped bp on exit side of first nucleosome, bare linker, unwrapped bp on entry side of second
    nucleosome, and wrapped bp on entry side of second nucleosome.

    Parameters
    ----------
    links : (L,) array-like
        linker length in bp
    w_ins : float or (L+1,) array_like
        amount of DNA wrapped on entry side of central dyad base in bp
    w_outs : float or (L+1,) array_like
        amount of DNA wrapped on exit side of central dyad base in bp
    unwraps: float or (L+1,) array-like
        total amount of DNA unwrapped on both sides of nucleosome in bp

    Returns
    -------
    ldna : (L,) array-like
        cumulative length of chain in genomic distance (including wrapped and unwrapped bp)
    """
    b = helix_params['b']
    num_linkers = len(links)
    w_ins, w_outs = resolve_wrapping_params(unwraps, w_ins, w_outs, num_linkers+1)
    # calculate unwrapping amounts based on w_ins and w_outs
    mu_ins = (b - 1)/2 - w_ins
    mu_outs = (b - 1)/2 - w_outs
    ldna = np.zeros_like(links).astype('float')
    ldna[0] = w_outs[0] + mu_outs[0] + links[0] + mu_ins[1] + w_ins[1]
    for i in range(1, num_linkers):
        ldna[i] = ldna[i-1] + w_outs[i] + mu_outs[i] + links[i] + mu_ins[i+1] + w_ins[i+1]
    return ldna

def Rmax_from_links_unwraps(links, w_ins=default_w_in, w_outs=default_w_out,
                            helix_params=helix_params_best, unwraps=None):
    """Returns cumulative length of linkers (including unwrapping) as a function of
    the number of monomers along nucleosome chain.

    Parameters
    ----------
    links : (L,) array-like
        linker length in bp
    w_ins : float or (L+1,) array_like
        amount of DNA wrapped on entry side of central dyad base in bp
    w_outs : float or (L+1,) array_like
        amount of DNA wrapped on exit side of central dyad base in bp
    unwraps: float or (L+1,) array-like
        total amount of DNA unwrapped on both sides of nucleosome in bp

    Returns
    -------
    Rmax : (L,) array-like
        cumulative length of linkers in bp
    """
    b = helix_params['b']
    num_linkers = len(links)
    w_ins, w_outs = resolve_wrapping_params(unwraps, w_ins, w_outs, num_linkers+1)
    # calculate unwrapping amounts based on w_ins and w_outs
    mu_ins = (b - 1)/2 - w_ins
    mu_outs = (b - 1)/2 - w_outs
    Rmax = np.zeros_like(links).astype('float')
    Rmax[0] = mu_outs[0] + links[0] + mu_ins[1]
    for i in range(1, num_linkers):
        Rmax[i] = Rmax[i-1] + mu_outs[i] + links[i] + mu_ins[i+1]
    return Rmax
